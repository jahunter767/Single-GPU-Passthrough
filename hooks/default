#!/bin/bash

# Declaring global variables
declare -g DOMAIN_NAME
declare -g GUEST_NAME
declare -g HOOK_NAME
declare -g STATE_NAME
declare -g MISC
declare -g HOOK_FOLDER
declare -g TMP_CONFIG_PATH
declare -g LOG_FILE

DOMAIN_NAME="$(basename "${0}")"
GUEST_NAME="${1}"
HOOK_NAME="${2}"
STATE_NAME="${3}"
MISC="${@:4}"

HOOK_FOLDER="${0%/${DOMAIN_NAME}}"
TMP_CONFIG_PATH="tmp/libvirt-${GUEST_NAME}"
LOG_FILE="${HOOK_FOLDER}/${DOMAIN_NAME}.d/${GUEST_NAME}/vm.log"

##############################################################################
# Parse XML and create a file system in tmp representing its structure then
# loads the data into the relevant variables using the load_config_data function
# implemented in ${HOOK_FOLDER}/default.d/${DOMAIN_NAME}
#
# @TODO: Double check regexps that failed in the script but worked in and
#        interactive shell
#        Improve the speed that the XML is parsed
##############################################################################

function parse_xml {
    if [ -z "$(command -v "load_config_data")" ]; then
        echo "ERROR: load_config_data not defined in ${HOOK_FOLDER}/default.d/${DOMAIN_NAME}"
    fi

    mkdir -p "${TMP_CONFIG_PATH}"
    mkdir -p "${TMP_CONFIG_PATH}/state"
    declare -a tag_stack
    declare -i stack_ptr
    stack_ptr=0
    tag_path="${TMP_CONFIG_PATH}"
    parent_tag_path="${TMP_CONFIG_PATH}"

    while read xml_line; do
    if [ -n "${xml_line}" ]; then
        #echo "######################################################################"
        #echo "Line: ${xml_line}"

        # Strip everything from the first closing angle bracket onwards
        tag_name=${xml_line%%>*}
        tag_name=${tag_name%/}
        # Strip args from tag
        #tag_name=${tag_name%%*( *=\"*\")*(/)+(>)*}
        tag_name=${tag_name%% *=\"*\"}

        #echo "Name: ${tag_name}"

        if [[ "${tag_name}" =~ "</${tag_stack[$stack_ptr]}" ]]; then
            # If the tag is a closing tag
            parent_tag_path="${parent_tag_path%/${tag_stack[$stack_ptr]}-*}"
            parent_tag_path="${parent_tag_path%/${tag_stack[$stack_ptr]}}"
            stack_ptr=$(( ${stack_ptr} - 1 ))
        elif [[ "${tag_name}" =~ ([<])([^ ])+ ]]; then
            # If the tag is an opening tag
            tag_name="${tag_name#*<}"

            # Matches tags like this <test arg="a1"/>
            read pred1 <<< $(echo "${xml_line}" |
                grep -Pm1 $"<${tag_name}([[:space:]]*[[:word:]]*=\"[^ ]*\")*/>"$)
            # Matches lines like this <test>value</test>
            read pred2 <<< $(echo "${xml_line}" |
                grep -Pm1 $"<${tag_name}([[:space:]]*[[:word:]]*=\"[^ ]*\")*>[^ ]*</${tag_name}>"$)

            # If the tag isn't closed in the current line, update the tag stack
            if [[ "${pred1}" == "" && "${pred2}" == "" ]]; then
                # Update tag stack
                if [[ "${tag_stack[${stack_ptr}]}" != "${tag_name}" ]]; then
                    stack_ptr=$(( ${stack_ptr} + 1 ))
                    tag_stack[${stack_ptr}]="${tag_name}"

                    parent_tag_path="${parent_tag_path}/${tag_stack[$stack_ptr]}"
                    tag_path="${parent_tag_path}"
                fi
            else
                tag_path="${parent_tag_path}/${tag_name}"
            fi

            if [ -d "${tag_path}" ]; then
                # If there aren't any subfolders for each repreated tag then we can
                # assume that the existing folder is the first instance of that tag
                # so we rename it to reflect that, create a new folder with the tag
                # name and move it into that
                if [ ! -d "${tag_path}/${tag_name}-1" ] ; then
                    mv "${tag_path}" "${tag_path}-1"
                    mkdir -p "${tag_path}"
                    mv "${tag_path}-1" "${tag_path}/"
                fi

                readarray dir_lst <<< $(ls -d1 ${tag_path}/${tag_name}-*)
                tag_path="${tag_path}/${tag_name}-$(( ${#dir_lst[@]} + 1 ))"
                # If the current parent tag is is the repeated tag then save the
                # new path so it may be preserved for the nested tags. It will be
                # reset once the closing parent tag is encountered
                if [[ ${tag_name} == ${tag_stack[$stack_ptr]} ]]; then
                    parent_tag_path="${tag_path}"
                fi
            fi
            mkdir -p "${tag_path}"

            ######################################################################
            #echo "Tag Name  =${tag_name}"
            #echo "Tag Stack =${tag_stack[@]:0:${stack_ptr}}"
            #echo "Stack Ptr =${stack_ptr}"
            #echo "P.Tag Path =${parent_tag_path}"
            #echo "Tag Path   =${tag_path}"
            ######################################################################

            # Parse for string body between tags
            value="${xml_line#*<${tag_name}*>}"
            value="${value%*</${tag_name}*>}"
            if [[ "${value}" != "" ]]; then
                #echo "Value     =${value}"
                echo "${value}" > "${tag_path}/value"
            fi

            # Parse for tag args
            #echo "Args:"
            while read arg; do
                if [[ "${arg}" != "" ]]; then
                    val="${arg##*=\"}"
                    #echo -e "\t${arg%%=*} = ${val%\"}  [raw: ${arg}]"
                    echo "${val%\"}" > "${tag_path}/${arg%%=*}.val"
                fi
            done <<< $(echo ${xml_line} | grep -oP "([[:space:]]*[^ ]*=\"[^ ]*\")")
        else
            # The line is the body of a parent tag so append it's value to the
            # value file in the parent tag folder
            echo "${xml_line}" >> "${parent_tag_path}/value"
        fi
    fi
    done < /dev/stdin

    load_config_data
} # End-parse_xml

function parse_description_args {
    local desc="${1}"
    read args <<< $(echo "${desc}" |
        grep -oPm1 "(args\[)([[:space:]]*--[[:word:]-]+)+([[:space:]]*\])")
    echo "${args}" | grep -oP "(--[[:word:]-]+)"
} # End-parse_description_args

##############################################################################
# Read in all the functions needed for the VM. Reads in the default scripts
# first so users can override functions by redefining them in the unique
# path for the VM being started.
# Order scripts are read:
#     1. ${HOOK_FOLDER}/default.d/${DOMAIN_NAME}
#     2. ${HOOK_FOLDER}/${DOMAIN_NAME}.d/default/${HOOK_NAME}/${STATE_NAME}
#     3. ${HOOK_FOLDER}/${DOMAIN_NAME}.d/${GUEST_NAME}/${HOOK_NAME}/${STATE_NAME}
##############################################################################

function include_functions {
    hpath="${1}"

    # Author: Sebastiaan Meijer (sebastiaan@passthroughpo.st)
    # check if it's a non-empty executable file
    if [ -f "${hpath}" ] && [ -s "${hpath}" ] && [ -x "${hpath}" ]; then
        source "${hpath}" "$@"
    elif [ -d "${hpath}" ]; then
        while read file; do
            # check for null string
            if [ ! -z "${file}" ]; then
                source "${file}" "$@"
            fi
        done <<< "$(find -L "${hpath}" -maxdepth 1 -type f -executable -print;)"
    fi
} # End-include_functions

include_functions "${HOOK_FOLDER}/default.d/${DOMAIN_NAME}"
include_functions "${HOOK_FOLDER}/${DOMAIN_NAME}.d/default/${HOOK_NAME}/${STATE_NAME}"
include_functions "${HOOK_FOLDER}/${DOMAIN_NAME}.d/${GUEST_NAME}/${HOOK_NAME}/${STATE_NAME}"
